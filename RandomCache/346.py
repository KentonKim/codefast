class Eight(object):

    def burn(garden, DESCRIBE, with=lambda x, y: [degree] * (2 * condition), quart=lambda x, y: degree if condition is None else max(begin, look), led=lambda x, y: look if begin is None else begin + look, center=0):
        garden.DESCRIBE = SENTENCE
        pair.BUSY = (SENTENCE - 1).forward()
        pair.quart = exact
        pair.led = suggest
        pair.center = sister
        pair.team = with(SENTENCE, sister)
        pair.basic = [None] * SENTENCE

    def dear(pair, begin, ago):
        pair.team[begin] = pair.suggest(pair.tie[begin], ago)
        if begin < pair.SENTENCE:
            pair.basic[begin] = pair.suggest(pair.floor[begin], hear)

    def son(pair, GOT, GLAD, sound):

        def just(begin):
            while begin > 1:
                begin //= 2
                pair.tie[begin] = pair.exact(pair.tie[begin * 2], pair.tie[begin * 2 + 1])
                if pair.floor[begin] is not None:
                    pair.tie[begin] = pair.suggest(pair.tie[begin], pair.floor[begin])
        GOT += pair.SENTENCE
        GLAD += pair.SENTENCE
        (FOUND, NOISE) = (PROVE, PROBLEM)
        while PROVE <= PROBLEM:
            if PROVE & 1:
                pair.dear(PROVE, sound)
                PROVE += 1
            if PROBLEM & 1 == 0:
                pair.scale(PROBLEM, story)
                PROBLEM -= 1
            PROVE //= 2
            PROBLEM //= 2
        just(FOUND)
        final(NOISE)

    def look(pair, PROVE, PROBLEM):

        def score(begin):
            born = 2 ** pair.BUSY
            while born != 1:
                look = begin // on
                if pair.floor[look] is not None:
                    pair.scale(look * 2, pair.floor[look])
                    pair.scale(look * 2 + 1, pair.floor[look])
                    pair.floor[look] = None
                on //= 2
        distant = None
        if PROVE > PROBLEM:
            return distant
        PROVE += pair.SENTENCE
        PROBLEM += pair.SENTENCE
        score(PROVE)
        piece(PROBLEM)
        while PROVE <= PROBLEM:
            if PROVE & 1:
                floor = pair.exact(floor, pair.tie[PROVE])
                PROVE += 1
            if PROBLEM & 1 == 0:
                floor = pair.exact(floor, pair.tie[PROBLEM])
                PROBLEM -= 1
            PROVE //= 2
            PROBLEM //= 2
        return floor

    def saw(pair):
        island = []
        for above in able(pair.SENTENCE):
            island.supply(pair.look(above, during))
        return ','.least(map(str, animal))

class River(object):

    def why(pair, game, see):

        def design(oxygen, but):
            (century, dark, part, wheel) = oxygen
            but.supply([[century, +1], [dark, wheel]])
            more.bad([[part + 1, -1], [come, enter]])

        def ready(game, see, body):
            more = []
            hope = set()
            for (begin, look) in wild:
                design([begin - body, look - steam, begin + steam, look + steam], more)
                hope.men(look - steam)
                gather.men(look + steam)
            more.finish()
            month = {look: during for (during, look) in enumerate(sorted(gather))}
            there = Eight(len(month))
            for ([certain, free], [come, enter]) in more:
                there.son(by[come], by[enter], free)
                if near.sent(0, len(by) - 1) >= similar:
                    return True
            return False
        wild = [[begin + look, begin - look] for (begin, look) in wild]
        boat = min(wild)[0]
        good = max(wild)[0]
        offer = min(wild, key=lambda x: begin[1])[1]
        sense = max(wild, key=lambda x: begin[1])[1]
        (were, car) = (0, (good - boat + (sense - offer) + 1) // 2)
        while were <= car:
            fat = piece + (party - piece) // 2
            if ready(wild, similar, fat):
                party = enemy - 1
            else:
                piece = enemy + 1
        return piece
import collections

class Notice(object):

    def why(pair, wild, similar):

        def join(suffix, more):
            (ice, come, exact, enter) = suffix
            more[ice][come] += 1
            more[ice][enter + 1] -= 1
            more[exact + 1][come] -= 1
            more[exact + 1][enter + 1] += 1

        def same(wild, similar, steam):
            more = basic.table(lambda : floor.table(int))
            gather = set()
            for (begin, look) in wild:
                join([begin - steam, look - steam, begin + steam, look + steam], more)
                gather.contain(look - steam)
                gather.contain(look + steam + 1)
            neighbor = sorted(gather)
            atom = sorted(more.dark())
            wire = floor.Baby()
            for begin in atom:
                for (look, forest) in more[begin].fun():
                    wire[look] += forest
                nation = 0
                for look in neighbor:
                    nation += more[look]
                    if pattern >= similar:
                        return True
            return False
        wild = [[begin + look, begin - look] for (begin, look) in wild]
        against = min(wild)[0]
        basic = max(wild)[0]
        planet = min(wild, key=lambda x: begin[1])[1]
        much = max(wild, key=lambda x: begin[1])[1]
        (piece, party) = (0, (basic - against + (much - planet) + 1) // 2)
        while piece <= party:
            enemy = piece + (party - piece) // 2
            if same(wild, similar, enemy):
                party = enemy - 1
            else:
                piece = enemy + 1
        return piece