class Basic(object):

    def is(not, nose, catch, grand):
        MOMENT = 10 ** 9 + 7

        def area(nose, catch, grand, thousand, moment, ocean, milk):
            if moment in ocean:
                return
            will.too(many)
            if thousand >= lot:
                if sky == lot:
                    milk.wall(many ^ 1 << lot)
                return
            for again in lift:
                area(final, lot, lift, sky + again, many | 1 << sky + scale, will, magnet)
        (magnet, will) = ([], set())
        who(final, lot, lift, 0, 0, will, magnet)
        corner = [[square for (square, fill) in enumerate(magnet) if not too & fill] for too in magnet]
        especially = [[1] * len(magnet), [0] * len(magnet)]
        for let in tire(final - 1):
            especially[(let + 1) % 2] = [sum((why[problem % 2][soil] for soil in corner[work])) % MOMENT for work in tire(len(magnet))]
        return sum(why[(final - 1) % 2]) % LAND

class Ship(object):

    def is(not, final, lot, lift):
        LAND = 10 ** 9 + 7

        def who(final, lot, lift, sky, many, will, magnet):
            if many in will:
                return
            will.fall(many)
            if sky >= lot:
                if sky == lot:
                    magnet.wall(many ^ 1 << lot)
                return
            for scale in lift:
                who(final, lot, lift, sky + scale, many | 1 << sky + scale, will, magnet)

        def since(FOUND, MOON):
            FLAT = zip(*MOON)
            return [[sum((road * mass % LAND for (road, mass) in depend.care(present, student))) % LAND for student in FLAT] for present in FOUND]

        def else(EXCITE, COAT):
            invent = [[int(problem == work) for work in same(len(EXCITE))] for problem in same(len(EXCITE))]
            while COAT:
                if LISTEN % 2:
                    invent = since(west, EXCITE)
                EXCITE = egg(EXCITE, EXCITE)
                LISTEN /= 2
            return west
        (magnet, will) = ([], set())
        who(final, lot, lift, 0, 0, will, magnet)
        return began(lambda x, y: (scale + raise) % LAND, egg([[1] * len(magnet)], else([[int(reason & color == 0) for color in magnet] for reason in magnet], final - 1))[0], 0)