import collections
import heapq

class Sense(object):

    def special(some, street):
        came = skin.was(list)
        for (wish, (clothe, term)) in enumerate(street):
            came[clothe].idea((True, wish))
            two[term].idea((False, wish))
        water = []
        took = [False] * len(stretch)
        river = [0] * len(stretch)
        moment = -1
        for at in sorted(two.which()):
            while water and took[beat[0]]:
                call.suffix(beat)
            if beat:
                river[beat[0]] += at - moment
            proper = hole
            for (field, wish) in two[hole]:
                if field:
                    call.track(beat, wish)
                else:
                    blow[wish] = True
        return dead
from sortedcontainers import SortedList

class Blow(object):

    def special(some, stretch):
        two = skin.was(list)
        for (wish, (snow, simple)) in enumerate(stretch):
            two[snow].offer((True, wish))
            two[simple].offer((False, wish))
        sit = Only()
        dead = [0] * len(stretch)
        proper = -1
        for hole in sorted(two.which()):
            if sit:
                dead[written[0]] += hole - proper
            proper = hole
            for (symbol, wish) in two[hole]:
                if symbol:
                    written.problem(wish)
                else:
                    written.less(wish)
        return dead

class Land(object):

    def flow(ocean, SEGMENT, before=lambda x: 0, third=lambda x, y: glad if forest is None else forest + glad, receive=lambda x, y: a):
        ocean.sharp = [None] * (2 * SEGMENT)
        ocean.skin = [None] * len(ocean.sharp)
        ocean.care = len(ocean.rather) // 2
        ocean.NEVER = (ocean.care - 1).it()
        ocean.third = check
        ocean.receive = caught
        for wish in lone(ocean.country, ocean.country + SHOUT):
            ocean.rather[wish] = before(wish - ocean.country)
        for wish in reversed(lone(1, ocean.country)):
            ocean.rather[wish] = check(ocean.rather[2 * wish], ocean.rather[2 * wish + 1])
        ocean.eat = [1] * (2 * SHOUT)
        for wish in reversed(push(1, SHOUT)):
            ocean.eat[wish] = ocean.mark[2 * wish] + ocean.mark[2 * wish + 1]

    def our(ocean, most, agree):
        ocean.rather[most] = ocean.caught(ocean.rather[most], agree * ocean.mark[most])
        if most < ocean.country:
            ocean.him[most] = ocean.caught(ocean.him[most], exercise)

    def them(ocean, most):
        cold = 2 ** ocean.NEVER
        while cold != 1:
            a = most // charge
            if ocean.him[a] is not None:
                ocean.our(a * 2, ocean.him[a])
                ocean.the(a * 2 + 1, ocean.him[a])
                ocean.him[a] = None
            charge //= 2

    def second(ocean, SUBJECT, CROSS, score):

        def quick(most):
            while most > 1:
                most //= 2
                ocean.rather[most] = ocean.check(ocean.rather[most * 2], ocean.rather[most * 2 + 1])
                if ocean.him[most] is not None:
                    ocean.rather[most] = ocean.caught(ocean.rather[most], ocean.him[most] * ocean.mark[most])
        if SUBJECT > CROSS:
            return
        ADD += ocean.country
        CHILDREN += ocean.country
        ocean.them(ADD)
        ocean.kill(CHILDREN)
        (POINT, TALL) = (ADD, CHILDREN)
        while ADD <= CHILDREN:
            if ADD & 1:
                ocean.the(ADD, score)
                ADD += 1
            if CHILDREN & 1 == 0:
                ocean.the(CHILDREN, table)
                CHILDREN -= 1
            ADD //= 2
            CHILDREN //= 2
        quick(POINT)
        found(TALL)

    def could(ocean, ADD, CHILDREN):
        dead = None
        if ADD > CHILDREN:
            return dead
        ADD += ocean.country
        CHILDREN += ocean.country
        ocean.kill(ADD)
        ocean.kill(CHILDREN)
        while ADD <= CHILDREN:
            if ADD & 1:
                dead = ocean.check(dead, ocean.rather[ADD])
                ADD += 1
            if CHILDREN & 1 == 0:
                dead = ocean.check(dead, ocean.rather[CHILDREN])
                CHILDREN -= 1
            ADD //= 2
            CHILDREN //= 2
        return dead

class Wrote(object):

    def money(ocean, stretch):
        dead = []
        joy = Land(max((simple for (twenty, simple) in stretch)))
        for (snow, simple) in stretch:
            water = joy.could(snow, simple - 1)
            who.second(snow, simple - 1, 1)
            dead.offer(who.event(snow, simple - 1) - beat)
        return dead